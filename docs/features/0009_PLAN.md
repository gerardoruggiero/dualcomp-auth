# Plan Técnico - Creación de Entidades Titles y DocumentTypes

## Descripción
Crear dos nuevas entidades (Títulos y Tipos de Documentos) que sigan exactamente el mismo patrón que las entidades existentes que heredan de `BaseTypeEntity` (AddressTypes, EmailTypes, PhoneTypes, SocialMediaTypes). Estas entidades deben tener funcionalidad completa CRUD tanto en backend como frontend, replicando la implementación del componente `phone-type` como referencia.

## Entidades a Crear
1. **Titles** (Títulos): Para títulos profesionales como "Ingeniero", "Doctor", etc.
2. **DocumentTypes** (Tipos de Documentos): Para tipos de documentos como "DNI", "Pasaporte", etc.

## Análisis del Patrón Existente

### Backend - Estructura Base
- **BaseTypeEntity**: Clase abstracta con propiedades `Name`, `Description`, `IsActive`
- **BaseTypesController**: Controller genérico que maneja operaciones CRUD para entidades de tipo
- **Patrón de comandos**: `Create[Entity]Command`, `Update[Entity]Command`
- **Patrón de queries**: `Get[Entity]sQuery`, `Get[Entity]sResult`
- **Configuración EF**: Cada entidad tiene su `[Entity]Configuration`
- **Repositorio**: Cada entidad tiene su repositorio específico

### Frontend - Estructura Base
- **BaseTypeService**: Servicio abstracto genérico para operaciones CRUD
- **Componente específico**: Hereda funcionalidad de componentes base
- **Modelos**: Interfaces que extienden `BaseTypeEntity`
- **Data Table**: Componente reutilizable para mostrar listas

## Archivos a Modificar/Crear

### 1. Backend - Base de Datos

#### Scripts SQL
**Archivo**: `src/backend/Dualcomp.Auth.Database/Scripts/005_TitlesAndDocumentTypes.sql`
```sql
-- Crear tabla Titles
CREATE TABLE Titles (
    Id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    Name NVARCHAR(50) NOT NULL,
    Description NVARCHAR(200),
    IsActive BIT NOT NULL DEFAULT 1,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    CONSTRAINT UK_Titles_Name UNIQUE (Name)
);

-- Crear tabla DocumentTypes
CREATE TABLE DocumentTypes (
    Id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    Name NVARCHAR(50) NOT NULL,
    Description NVARCHAR(200),
    IsActive BIT NOT NULL DEFAULT 1,
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    CONSTRAINT UK_DocumentTypes_Name UNIQUE (Name)
);

-- Insertar datos iniciales para Titles
INSERT INTO Titles (Id, Name, Description) VALUES
(NEWID(), 'Ingeniero', 'Título de Ingeniero'),
(NEWID(), 'Doctor', 'Título de Doctor'),
(NEWID(), 'Licenciado', 'Título de Licenciado'),
(NEWID(), 'Técnico', 'Título de Técnico'),
(NEWID(), 'Magíster', 'Título de Magíster'),
(NEWID(), 'Especialista', 'Título de Especialista'),
(NEWID(), 'Bachiller', 'Título de Bachiller'),
(NEWID(), 'Postgrado', 'Título de Postgrado');

-- Insertar datos iniciales para DocumentTypes
INSERT INTO DocumentTypes (Id, Name, Description) VALUES
(NEWID(), 'DNI', 'Documento Nacional de Identidad'),
(NEWID(), 'Pasaporte', 'Pasaporte'),
(NEWID(), 'Cédula', 'Cédula de Identidad'),
(NEWID(), 'RUC', 'Registro Único de Contribuyentes'),
(NEWID(), 'Carné de Extranjería', 'Carné de Extranjería'),
(NEWID(), 'Carné de Identidad', 'Carné de Identidad'),
(NEWID(), 'Licencia de Conducir', 'Licencia de Conducir'),
(NEWID(), 'Permiso de Trabajo', 'Permiso de Trabajo');
```

### 2. Backend - Dominio

#### Entidades del Dominio
**Archivo**: `src/backend/Dualcomp.Auth.Domain/Companies/TitleEntity.cs`
```csharp
namespace Dualcomp.Auth.Domain.Companies
{
    public class TitleEntity : BaseTypeEntity
    {
        private TitleEntity() { }

        private TitleEntity(string name, string? description = null) : base(name, description)
        {
        }

        public static TitleEntity Create(string name, string? description = null)
            => new TitleEntity(name, description);
    }
}
```

**Archivo**: `src/backend/Dualcomp.Auth.Domain/Companies/DocumentTypeEntity.cs`
```csharp
namespace Dualcomp.Auth.Domain.Companies
{
    public class DocumentTypeEntity : BaseTypeEntity
    {
        private DocumentTypeEntity() { }

        private DocumentTypeEntity(string name, string? description = null) : base(name, description)
        {
        }

        public static DocumentTypeEntity Create(string name, string? description = null)
            => new DocumentTypeEntity(name, description);
    }
}
```

### 3. Backend - DataAccess

#### Configuraciones EF
**Archivo**: `src/backend/Dualcomp.Auth.DataAccess.EntityFramework/Configurations/TitleConfiguration.cs`
```csharp
using Dualcomp.Auth.Domain.Companies;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace Dualcomp.Auth.DataAccess.EntityFramework.Configurations
{
    public class TitleConfiguration : IEntityTypeConfiguration<TitleEntity>
    {
        public void Configure(EntityTypeBuilder<TitleEntity> builder)
        {
            builder.ToTable("Titles");
            
            builder.HasKey(t => t.Id);
            
            builder.Property(t => t.Id).ValueGeneratedNever();
            
            builder.Property(t => t.Name)
                .IsRequired()
                .HasMaxLength(50);
                
            builder.Property(t => t.Description)
                .HasMaxLength(200);
                
            builder.Property(t => t.IsActive)
                .IsRequired();
                
            builder.HasIndex(t => t.Name)
                .IsUnique();
        }
    }
}
```

**Archivo**: `src/backend/Dualcomp.Auth.DataAccess.EntityFramework/Configurations/DocumentTypeConfiguration.cs`
```csharp
using Dualcomp.Auth.Domain.Companies;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace Dualcomp.Auth.DataAccess.EntityFramework.Configurations
{
    public class DocumentTypeConfiguration : IEntityTypeConfiguration<DocumentTypeEntity>
    {
        public void Configure(EntityTypeBuilder<DocumentTypeEntity> builder)
        {
            builder.ToTable("DocumentTypes");
            
            builder.HasKey(dt => dt.Id);
            
            builder.Property(dt => dt.Id).ValueGeneratedNever();
            
            builder.Property(dt => dt.Name)
                .IsRequired()
                .HasMaxLength(50);
                
            builder.Property(dt => dt.Description)
                .HasMaxLength(200);
                
            builder.Property(dt => dt.IsActive)
                .IsRequired();
                
            builder.HasIndex(dt => dt.Name)
                .IsUnique();
        }
    }
}
```

#### Repositorios
**Archivo**: `src/backend/Dualcomp.Auth.DataAccess.EntityFramework/Repositories/TitleRepository.cs`
```csharp
using Dualcomp.Auth.Domain.Companies;
using Dualcomp.Auth.DataAccess.EntityFramework;

namespace Dualcomp.Auth.DataAccess.EntityFramework.Repositories
{
    public class TitleRepository : EfRepository<TitleEntity>, ITitleRepository
    {
        public TitleRepository(BaseDbContext context) : base(context)
        {
        }
    }
}
```

**Archivo**: `src/backend/Dualcomp.Auth.DataAccess.EntityFramework/Repositories/DocumentTypeRepository.cs`
```csharp
using Dualcomp.Auth.Domain.Companies;
using Dualcomp.Auth.DataAccess.EntityFramework;

namespace Dualcomp.Auth.DataAccess.EntityFramework.Repositories
{
    public class DocumentTypeRepository : EfRepository<DocumentTypeEntity>, IDocumentTypeRepository
    {
        public DocumentTypeRepository(BaseDbContext context) : base(context)
        {
        }
    }
}
```

### 4. Backend - Application

#### Commands y Queries para Titles
**Archivos en**: `src/backend/Dualcomp.Auth.Application/Titles/`

**GetTitles/GetTitlesQuery.cs**
```csharp
using Dualcomp.Auth.Application.Abstractions.Messaging;

namespace Dualcomp.Auth.Application.Titles.GetTitles
{
    public record GetTitlesQuery() : IQuery<GetTitlesResult>;
}
```

**GetTitles/GetTitlesResult.cs**
```csharp
using Dualcomp.Auth.Application.Abstractions.Messaging;
using Dualcomp.Auth.Domain.Companies;

namespace Dualcomp.Auth.Application.Titles.GetTitles
{
    public record GetTitlesResult(IEnumerable<TitleEntity> Titles) : BaseTypeResult<TitleEntity>(Titles);
}
```

**CreateTitle/CreateTitleCommand.cs**
```csharp
using Dualcomp.Auth.Application.Abstractions.Commands;
using Dualcomp.Auth.Application.Abstractions.Messaging;
using Dualcomp.Auth.Domain.Companies;

namespace Dualcomp.Auth.Application.Titles.CreateTitle
{
    public record CreateTitleCommand(string Name, string? Description = null) 
        : ICommand<CreateTitleResult>, ICreateTypeCommand;

    public record CreateTitleResult(Guid Id, string Name, string? Description, bool IsActive) 
        : BaseTypeResult<TitleEntity>(Id, Name, Description, IsActive);
}
```

**UpdateTitle/UpdateTitleCommand.cs**
```csharp
using Dualcomp.Auth.Application.Abstractions.Commands;
using Dualcomp.Auth.Application.Abstractions.Messaging;
using Dualcomp.Auth.Domain.Companies;

namespace Dualcomp.Auth.Application.Titles.UpdateTitle
{
    public record UpdateTitleCommand(Guid Id, string Name, string? Description = null, bool IsActive = true) 
        : ICommand<UpdateTitleResult>, IUpdateTypeCommand;

    public record UpdateTitleResult(Guid Id, string Name, string? Description, bool IsActive) 
        : BaseTypeResult<TitleEntity>(Id, Name, Description, IsActive);
}
```

#### Commands y Queries para DocumentTypes
**Archivos en**: `src/backend/Dualcomp.Auth.Application/DocumentTypes/`

Estructura idéntica a Titles pero con `DocumentType` en lugar de `Title`.

### 5. Backend - Controllers

**Archivo**: `src/backend/Dualcomp.Auth.WebApi/Controllers/TitlesController.cs`
```csharp
using Dualcomp.Auth.Application.Titles.GetTitles;
using Dualcomp.Auth.Application.Titles.CreateTitle;
using Dualcomp.Auth.Application.Titles.UpdateTitle;
using Dualcomp.Auth.Application.Abstractions.Messaging;
using Microsoft.AspNetCore.Mvc;

namespace Dualcomp.Auth.WebApi.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class TitlesController : BaseTypesController<
        GetTitlesQuery, 
        GetTitlesResult,
        CreateTitleCommand,
        CreateTitleResult,
        UpdateTitleCommand,
        UpdateTitleResult>
    {
        public TitlesController(
            IQueryHandler<GetTitlesQuery, GetTitlesResult> queryHandler,
            ICommandHandler<CreateTitleCommand, CreateTitleResult> createCommandHandler,
            ICommandHandler<UpdateTitleCommand, UpdateTitleResult> updateCommandHandler)
            : base(queryHandler, createCommandHandler, updateCommandHandler)
        {
        }
    }
}
```

**Archivo**: `src/backend/Dualcomp.Auth.WebApi/Controllers/DocumentTypesController.cs`
```csharp
using Dualcomp.Auth.Application.DocumentTypes.GetDocumentTypes;
using Dualcomp.Auth.Application.DocumentTypes.CreateDocumentType;
using Dualcomp.Auth.Application.DocumentTypes.UpdateDocumentType;
using Dualcomp.Auth.Application.Abstractions.Messaging;
using Microsoft.AspNetCore.Mvc;

namespace Dualcomp.Auth.WebApi.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class DocumentTypesController : BaseTypesController<
        GetDocumentTypesQuery, 
        GetDocumentTypesResult,
        CreateDocumentTypeCommand,
        CreateDocumentTypeResult,
        UpdateDocumentTypeCommand,
        UpdateDocumentTypeResult>
    {
        public DocumentTypesController(
            IQueryHandler<GetDocumentTypesQuery, GetDocumentTypesResult> queryHandler,
            ICommandHandler<CreateDocumentTypeCommand, CreateDocumentTypeResult> createCommandHandler,
            ICommandHandler<UpdateDocumentTypeCommand, UpdateDocumentTypeResult> updateCommandHandler)
            : base(queryHandler, createCommandHandler, updateCommandHandler)
        {
        }
    }
}
```

### 6. Frontend - Modelos

**Archivo**: `src/frontend/src/app/shared/models/title.models.ts`
```typescript
import { BaseTypeEntity, CreateBaseTypeCommand, UpdateBaseTypeCommand, BaseTypeResult, BaseTypeListResult } from './base-type.models';

// Interfaces específicas para Title
export interface TitleEntity extends BaseTypeEntity {}

export interface CreateTitleCommand extends CreateBaseTypeCommand {}

export interface UpdateTitleCommand extends UpdateBaseTypeCommand {}

export interface TitleResult extends BaseTypeResult {}

export interface TitleListResult extends BaseTypeListResult {}

// Formulario para Title
export interface TitleForm {
  name: string;
  description: string;
}
```

**Archivo**: `src/frontend/src/app/shared/models/document-type.models.ts`
```typescript
import { BaseTypeEntity, CreateBaseTypeCommand, UpdateBaseTypeCommand, BaseTypeResult, BaseTypeListResult } from './base-type.models';

// Interfaces específicas para DocumentType
export interface DocumentTypeEntity extends BaseTypeEntity {}

export interface CreateDocumentTypeCommand extends CreateBaseTypeCommand {}

export interface UpdateDocumentTypeCommand extends UpdateBaseTypeCommand {}

export interface DocumentTypeResult extends BaseTypeResult {}

export interface DocumentTypeListResult extends BaseTypeListResult {}

// Formulario para DocumentType
export interface DocumentTypeForm {
  name: string;
  description: string;
}
```

### 7. Frontend - Servicios

**Archivo**: `src/frontend/src/app/shared/services/title.service.ts`
```typescript
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { BaseTypeService } from './base-type.service';
import { 
  TitleEntity,
  CreateTitleCommand,
  UpdateTitleCommand,
  TitleResult,
  TitleListResult
} from '../models/title.models';
import { environment } from '../../environments/environment';

@Injectable({
  providedIn: 'root'
})
export class TitleService extends BaseTypeService<
  TitleEntity,
  CreateTitleCommand,
  UpdateTitleCommand,
  TitleResult,
  TitleListResult
> {
  protected apiUrl = `${environment.apiBaseUrl}/titles`;

  protected mapBackendResponse(response: any): TitleEntity[] {
    console.log('TitleService - Respuesta del backend:', response);
    
    if (!response || !response.titles) {
      console.warn('TitleService - Respuesta vacía o sin titles:', response);
      return [];
    }
    
    const mappedItems = response.titles.map((item: any) => ({
      id: item.id,
      name: item.name || item.value,
      description: item.description || '',
      isActive: item.isActive !== undefined ? item.isActive : true
    }));
    
    console.log('TitleService - Items mapeados:', mappedItems);
    return mappedItems;
  }
}
```

**Archivo**: `src/frontend/src/app/shared/services/document-type.service.ts`
```typescript
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { BaseTypeService } from './base-type.service';
import { 
  DocumentTypeEntity,
  CreateDocumentTypeCommand,
  UpdateDocumentTypeCommand,
  DocumentTypeResult,
  DocumentTypeListResult
} from '../models/document-type.models';
import { environment } from '../../environments/environment';

@Injectable({
  providedIn: 'root'
})
export class DocumentTypeService extends BaseTypeService<
  DocumentTypeEntity,
  CreateDocumentTypeCommand,
  UpdateDocumentTypeCommand,
  DocumentTypeResult,
  DocumentTypeListResult
> {
  protected apiUrl = `${environment.apiBaseUrl}/documenttypes`;

  protected mapBackendResponse(response: any): DocumentTypeEntity[] {
    console.log('DocumentTypeService - Respuesta del backend:', response);
    
    if (!response || !response.documentTypes) {
      console.warn('DocumentTypeService - Respuesta vacía o sin documentTypes:', response);
      return [];
    }
    
    const mappedItems = response.documentTypes.map((item: any) => ({
      id: item.id,
      name: item.name || item.value,
      description: item.description || '',
      isActive: item.isActive !== undefined ? item.isActive : true
    }));
    
    console.log('DocumentTypeService - Items mapeados:', mappedItems);
    return mappedItems;
  }
}
```

### 8. Frontend - Componentes

**Archivo**: `src/frontend/src/app/title/title.component.ts`
```typescript
import { ChangeDetectionStrategy, Component, inject, signal, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { TypeModalComponent, TypeModalConfig } from '../shared/components/type-modal/type-modal.component';
import { TitleService } from '../shared/services/title.service';
import { 
  TitleEntity, 
  CreateTitleCommand, 
  UpdateTitleCommand,
  TitleListResult 
} from '../shared/models/title.models';
import { 
  DataTableComponent,
  DataTableColumn, 
  DataTableAction,
  DataTableConfig 
} from '../shared/components/data-table/data-table.component';

@Component({
  selector: 'app-title',
  standalone: true,
  imports: [CommonModule, DataTableComponent, TypeModalComponent],
  templateUrl: './title.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class TitleComponent implements OnInit {
  private titleService = inject(TitleService);

  // Estado del componente
  items = signal<TitleEntity[]>([]);
  totalCount = signal(0);
  currentPage = signal(1);
  totalPages = signal(1);
  pageSize = signal(10);
  searchTerm = signal('');
  isLoading = signal(false);
  isSearching = signal(false);
  errorMessage = signal<string | null>(null);

  // Configuración del modal
  modalConfig = signal<TypeModalConfig>({
    title: 'Agregar Título',
    nameLabel: 'Nombre del Título',
    descriptionLabel: 'Descripción',
    namePlaceholder: 'Ej: Ingeniero, Doctor...',
    descriptionPlaceholder: 'Descripción del título (opcional)',
    saveButtonText: 'Guardar',
    cancelButtonText: 'Cancelar'
  });

  // Configuración de la tabla
  columns: DataTableColumn[] = [
    { key: 'name', label: 'Nombre', sortable: true },
    { key: 'description', label: 'Descripción', sortable: false },
    { key: 'isActive', label: 'Estado', sortable: true }
  ];

  actions: DataTableAction[] = [
    { key: 'edit', label: 'Editar', icon: 'fas fa-edit', class: 'btn-primary' },
    { key: 'delete', label: 'Eliminar', icon: 'fas fa-trash', class: 'btn-danger' }
  ];

  tableConfig: DataTableConfig = {
    showSearch: true,
    showPagination: true,
    pageSizeOptions: [5, 10, 20, 50],
    emptyMessage: 'No hay títulos registrados'
  };

  ngOnInit(): void {
    this.loadTitles();
  }

  loadTitles(): void {
    this.isLoading.set(true);
    this.errorMessage.set(null);

    this.titleService.getTypes(
      this.currentPage(),
      this.pageSize(),
      this.searchTerm() || undefined
    ).subscribe({
      next: (result: TitleListResult) => {
        this.items.set(result.items);
        this.totalCount.set(result.totalCount);
        this.currentPage.set(result.page);
        this.totalPages.set(result.totalPages);
        this.isLoading.set(false);
        this.isSearching.set(false);
      },
      error: (error) => {
        console.error('Error cargando títulos:', error);
        this.errorMessage.set('Error al cargar los títulos. Por favor, intente nuevamente.');
        this.isLoading.set(false);
        this.isSearching.set(false);
      }
    });
  }

  onAddType(): void {
    this.modalConfig.set({
      title: 'Agregar Título',
      nameLabel: 'Nombre del Título',
      descriptionLabel: 'Descripción',
      namePlaceholder: 'Ej: Ingeniero, Doctor...',
      descriptionPlaceholder: 'Descripción del título (opcional)',
      saveButtonText: 'Guardar',
      cancelButtonText: 'Cancelar'
    });
    // Lógica para abrir modal
  }

  onSearch(searchTerm: string): void {
    this.searchTerm.set(searchTerm);
    this.currentPage.set(1);
    this.isSearching.set(true);
    this.loadTitles();
  }

  onSort(sortConfig: { column: string; direction: 'asc' | 'desc' }): void {
    // Implementar lógica de ordenamiento
    console.log('Ordenar por:', sortConfig);
  }

  onPageChange(page: number): void {
    this.currentPage.set(page);
    this.loadTitles();
  }

  onEdit(item: TitleEntity): void {
    this.modalConfig.set({
      title: 'Editar Título',
      nameLabel: 'Nombre del Título',
      descriptionLabel: 'Descripción',
      namePlaceholder: 'Ej: Ingeniero, Doctor...',
      descriptionPlaceholder: 'Descripción del título (opcional)',
      saveButtonText: 'Actualizar',
      cancelButtonText: 'Cancelar'
    });
    // Lógica para abrir modal con datos del item
  }

  onDelete(item: TitleEntity): void {
    if (confirm(`¿Está seguro de que desea eliminar el título "${item.name}"?`)) {
      this.titleService.deactivateType(item.id).subscribe({
        next: () => {
          this.loadTitles();
        },
        error: (error) => {
          console.error('Error eliminando título:', error);
          this.errorMessage.set('Error al eliminar el título. Por favor, intente nuevamente.');
        }
      });
    }
  }
}
```

**Archivo**: `src/frontend/src/app/title/title.component.html`
```html
<div class="row">
  <div class="col-12">
    <div class="content-header">
      <div class="container-fluid">
        <div class="row mb-2">
          <div class="col-sm-6">
            <h1>Títulos</h1>
          </div>
        </div>
      </div>
    </div>

    <section class="content">
      <div class="container-fluid">
        <!-- Mensajes de estado -->
        <div *ngIf="errorMessage()" class="alert alert-danger alert-dismissible" role="alert">
          <button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button>
          <i class="fas fa-exclamation-triangle"></i>
          {{ errorMessage() }}
        </div>

        <!-- Loading inicial -->
        <div *ngIf="isLoading() && !isSearching()" class="text-center">
          <div class="spinner-border" role="status">
            <span class="sr-only">Cargando...</span>
          </div>
          <p class="mt-2">Cargando títulos...</p>
        </div>

        <!-- Data Table -->
        <app-data-table
          *ngIf="!isLoading() || isSearching()"
          title="Títulos"
          titleIcon="fas fa-graduation-cap"
          [columns]="columns"
          [data]="items()"
          [actions]="actions"
          [config]="tableConfig"
          [currentPage]="currentPage()"
          [totalPages]="totalPages()"
          [totalCount]="totalCount()"
          [pageSize]="pageSize()"
          [searchValue]="searchTerm()"
          (onAdd)="onAddType()"
          (onSearch)="onSearch($event)"
          (onSort)="onSort($event)"
          (onPageChange)="onPageChange($event)"
          (onAction)="handleAction($event)">
        </app-data-table>

        <!-- Modal para agregar/editar -->
        <app-type-modal
          [config]="modalConfig()"
          (onSave)="handleSave($event)"
          (onCancel)="handleCancel()">
        </app-type-modal>
      </div>
    </section>
  </div>
</div>
```


## Fases de Implementación

### Fase 1: Backend - Base de Datos y Dominio
1. Crear script SQL con tablas Titles y DocumentTypes
2. Crear entidades del dominio TitleEntity y DocumentTypeEntity
3. Crear configuraciones EF para las nuevas entidades
4. Actualizar BaseDbContext para incluir las nuevas entidades

### Fase 2: Backend - Application Layer
1. Crear comandos y queries para Titles
2. Crear comandos y queries para DocumentTypes
3. Crear handlers para los comandos y queries
4. Registrar servicios en el contenedor de dependencias

### Fase 3: Backend - Controllers
1. Crear TitlesController heredando de BaseTypesController
2. Crear DocumentTypesController heredando de BaseTypesController
3. Probar endpoints con Postman o similar

### Fase 4: Frontend - Modelos y Servicios
1. Crear modelos TypeScript para Titles y DocumentTypes
2. Crear servicios que hereden de BaseTypeService
3. Implementar mapeo de respuestas del backend

### Fase 5: Frontend - Componentes
1. Crear componente Title siguiendo el patrón de PhoneType
2. Crear componente DocumentType siguiendo el patrón de PhoneType
3. Integrar componentes en el routing y sidebar


## Consideraciones Técnicas

1. **Refactorización**: Si se detecta código duplicado entre las implementaciones de Titles y DocumentTypes, se debe crear una clase base común.

2. **Validaciones**: Implementar las mismas validaciones que existen en las entidades base (Name requerido, longitud máxima, etc.).

3. **Consistencia**: Mantener exactamente el mismo patrón de nomenclatura y estructura que las entidades existentes.

4. **Performance**: Las nuevas entidades seguirán el mismo patrón de paginación y filtrado que las existentes.

5. **Seguridad**: Aplicar las mismas políticas de autorización que los controllers existentes.

## Archivos de Configuración a Actualizar

1. **BaseDbContext.cs**: Agregar DbSet para Titles y DocumentTypes
2. **ServiceCollectionExtensions.cs**: Registrar nuevas configuraciones EF
3. **Program.cs**: Registrar nuevos servicios en el contenedor DI
4. **Routing del frontend**: Agregar rutas para los nuevos componentes
5. **Sidebar**: Agregar enlaces a las nuevas páginas

## Datos Iniciales

Se incluirán datos iniciales para ambas entidades:

**Titles**: Ingeniero, Doctor, Licenciado, Técnico, Magíster, Especialista, Bachiller, Postgrado
**DocumentTypes**: DNI, Pasaporte, Cédula, RUC, Carné de Extranjería, Carné de Identidad, Licencia de Conducir, Permiso de Trabajo

Los IDs se generan automáticamente usando NEWID() para garantizar unicidad y compatibilidad con SQL Server.

Este plan garantiza que las nuevas entidades sigan exactamente el mismo patrón que las existentes, manteniendo la consistencia del código y facilitando el mantenimiento futuro.
