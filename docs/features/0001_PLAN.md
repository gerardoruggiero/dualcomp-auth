# Plan Técnico: Proyecto Base .NET con Arquitectura Hexagonal (DDD, SOLID, Clean Code)

## Contexto

Construir una solución base en .NET usando **Domain-Driven Design (DDD)** con arquitectura **Hexagonal (Ports & Adapters)**, poniendo énfasis en **SOLID** y **Clean Code**.  
Todos los componentes reutilizables y transversales (repositorios base, servicios de dominio base, controladores base, etc.) deben vivir en un proyecto dedicado llamado `Infraestructure` para que puedan aprovecharse en múltiples soluciones.

---

## Resumen de la Solución

- Definir límites claros entre **Domain**, **Application**, **Infraestructure** (componentes compartidos) y la capa adaptadora **API**.  
- Usar **Ports** (interfaces) en Domain/Application y proveer **Adapters** en `Infraestructure` o adaptadores por aplicación.  
- Centralizar las abstracciones e implementaciones reutilizables en `Infraestructure`.  

---

## Estructura de la Solución

- **`src/Domain`**  
  - Propósito: Modelo de dominio puro y reglas de negocio. Sin dependencias externas.  
  - Componentes clave: Entidades, Value Objects, Agregados, Eventos de Dominio, Interfaces de Repositorios, Servicios de Dominio (interfaces), Especificaciones, Políticas.  

- **`src/Application`**  
  - Propósito: Casos de uso. Orquestación de lógica de negocio.  
  - Componentes clave: Comandos, Consultas, DTOs, Handlers, Validaciones, Mapeo, Resultados, Interfaces de servicios de aplicación.  

- **`src/Infraestructure`**  
  - Propósito: Componentes base reutilizables y transversales.  
  - Componentes clave: Repositorio genérico, Unit of Work, Servicios base, Controlador base, contexto base EF Core, helpers de mapeo, logging, middleware de excepciones, adapters de eventos y cache.  

- **`src/WebApi`**  
  - Propósito: Adaptador HTTP. Contiene la composición raíz (DI) y controla wiring entre Application e Infraestructure.  

- **`tests/*`**  
  - Pruebas unitarias y de integración para cada capa.  

---

## Límites de Puertos y Adaptadores

- **Domain y Application** definen puertos (ej. `IRepository<T>`, `IUnitOfWork`, `ICommandHandler<T>`).  
- **Infraestructure** implementa adaptadores (ej. repositorio EF, Unit of Work, logging, caching).  
- **WebApi** implementa adaptador HTTP (controladores).  
- **Domain** permanece libre de dependencias técnicas.  

---

## Convenciones DDD

- **Entidades y Agregados**: con invariantes, eventos de dominio y consistencia interna.  
- **Value Objects**: inmutables, igualdad por componentes, creados mediante fábricas con validación.  
- **Eventos de Dominio**: se disparan en agregados y se manejan en Application o mediante outbox en Infraestructure.  
- **Especificaciones**: encapsulan predicados de consultas, traducidos en Infraestructure.  

---

## Principios SOLID y Clean Code

- **SRP**: clases con una sola responsabilidad.  
- **OCP**: extensibles vía nuevos handlers/adapters.  
- **LSP**: contratos preservados en abstracciones.  
- **ISP**: interfaces pequeñas y enfocadas.  
- **DIP**: siempre depender de puertos, no de implementaciones.  
- **Clean Code**: nombres explícitos, guard clauses, early return, no modelos anémicos, uso de `Result` para errores esperados.  

---

## Preocupaciones Transversales

- **Validación**: en Application y mediante invariantes en Domain.  
- **Mapeo**: centralizado en `Infraestructure.Mapping`.  
- **Logging**: vía `Infraestructure.Logging.ILoggerAdapter`.  
- **Cache**: vía `Infraestructure.Caching.ICacheService`.  
- **Transacciones**: coordinadas por Application a través de `IUnitOfWork`.  
- **Errores**: traducidos a HTTP en el controlador base y gestionados con middleware.  

---

## Estrategia de Persistencia

- **Por defecto**: EF Core como base en Infraestructure, sin acoplar Domain.  
- **Alternativa**: reemplazar por Dapper u otro adaptador implementando los mismos puertos.  

---

## Estrategia de Testing

- **Domain**: pruebas unitarias puras.  
- **Application**: pruebas de handlers con fakes.  
- **Infraestructure**: pruebas de integración (repositorio, UoW, middleware).  
- **WebApi**: pruebas de controladores y respuestas HTTP.  

---

## Implementación por Fases (Opcional)

1. **Fase 1** – Definir primitivos de Domain y abstracciones (puertos, Result/Errors, comandos y queries).  
2. **Fase 2** – Infraestructura base: repositorio genérico, UoW, servicios base, controlador base, middleware, adapters de logging/caching.  
3. **Fase 3** – API mínima: WebApi con wiring básico y endpoints de ejemplo.  
4. **Fase 4** – Persistencia: scaffolding EF Core.  
5. **Fase 5** – Pruebas: unitarias e integración.  

---

## Requerimientos No Funcionales

- **Reusabilidad**: Infraestructure solo con componentes genéricos.  
- **Mantenibilidad**: límites claros, bajo acoplamiento.  
- **Observabilidad**: logging y correlación preparados.  
- **Internacionalización**: mensajes desacoplados para localización futura.  

---

## Checklist de Aceptación

- Solución con proyectos: Domain, Application, Infraestructure, WebApi, tests.  
- Puertos definidos en Domain/Application sin dependencias técnicas.  
- Implementaciones base en Infraestructure (repositorios, UoW, servicios, controladores, middleware, adapters).  
- WebApi integra Application + Infraestructure vía DI.  
- Pruebas scaffold en cada capa.  
