# Plan Técnico - CRUD de Tipos de Entidades

## Descripción
Implementar funcionalidad completa de creación, edición y listado para las entidades de tipos básicos:
- AddressTypeEntity
- EmailTypeEntity  
- PhoneTypeEntity
- SocialMediaTypeEntity

Cada entidad debe tener su pantalla de lista con grilla paginada, funcionalidad de creación y edición mediante modales, siguiendo el mismo patrón establecido en Company pero adaptado para entidades más simples.

## Análisis de la Estructura Actual

### Backend
- **Entidades**: Ya existen en `Dualcomp.Auth.Domain.Companies` con estructura consistente (Id, Name, Description, IsActive)
- **Base de datos**: Tablas creadas en `003_CompanyExtendedEntities.sql` con constraints de unicidad en Name
- **Controllers**: Existen controllers que heredan de `BaseTypesController` con método `GetTypes()`
- **Queries**: Implementadas para obtener listas de tipos

### Frontend  
- **Componentes existentes**: `email-type.component`, `phone-type.component`, etc. (solución vieja)
- **Patrón Company**: Usa `DataTableComponent`, `ContentHeaderComponent`, servicios con paginación
- **Routing**: Rutas configuradas en `app.routes.ts` y sidebar con enlaces
- **Servicios**: Existen servicios básicos para obtener tipos

## Archivos y Funciones a Modificar/Crear

### Backend

#### 1. Application Layer - Commands y Handlers Genéricos
**Crear abstracciones genéricas para tipos:**
- `src/backend/Dualcomp.Auth.Application/Abstractions/Commands/BaseTypeCommand.cs` - Comando base genérico
- `src/backend/Dualcomp.Auth.Application/Abstractions/Commands/BaseTypeCommandHandler.cs` - Handler base genérico
- `src/backend/Dualcomp.Auth.Application/Abstractions/Commands/BaseTypeResult.cs` - Resultado base genérico

**Implementaciones específicas (heredan de las abstracciones):**
- `src/backend/Dualcomp.Auth.Application/AddressTypes/CreateAddressType/` (3 archivos)
- `src/backend/Dualcomp.Auth.Application/AddressTypes/UpdateAddressType/` (3 archivos)
- `src/backend/Dualcomp.Auth.Application/EmailTypes/CreateEmailType/` (3 archivos)
- `src/backend/Dualcomp.Auth.Application/EmailTypes/UpdateEmailType/` (3 archivos)
- `src/backend/Dualcomp.Auth.Application/PhoneTypes/CreatePhoneType/` (3 archivos)
- `src/backend/Dualcomp.Auth.Application/PhoneTypes/UpdatePhoneType/` (3 archivos)
- `src/backend/Dualcomp.Auth.Application/SocialMediaTypes/CreateSocialMediaType/` (3 archivos)
- `src/backend/Dualcomp.Auth.Application/SocialMediaTypes/UpdateSocialMediaType/` (3 archivos)

**Estructura genérica propuesta:**
```csharp
// Comando base genérico
public abstract record BaseTypeCommand<TEntity>(string Name, string? Description) 
    : ICommand<BaseTypeResult<TEntity>>;

// Handler base genérico
public abstract class BaseTypeCommandHandler<TEntity, TRepository> 
    : ICommandHandler<BaseTypeCommand<TEntity>, BaseTypeResult<TEntity>>
    where TEntity : Entity
    where TRepository : IRepository<TEntity>;

// Resultado base genérico
public record BaseTypeResult<TEntity>(Guid Id, string Name, string? Description, bool IsActive);
```

#### 2. Controllers
**Extender BaseTypesController con métodos genéricos:**
- `src/backend/Dualcomp.Auth.WebApi/Controllers/BaseTypesController.cs` - Agregar métodos genéricos Create y Update
- Los controllers existentes heredarán automáticamente estos métodos sin cambios adicionales
- **Estructura propuesta para BaseTypesController:**
  ```csharp
  public abstract class BaseTypesController<TQuery, TResult, TCreateCommand, TCreateResult, TUpdateCommand, TUpdateResult> : ControllerBase
      where TQuery : IQuery<TResult>, new()
      where TResult : class
      where TCreateCommand : ICommand<TCreateResult>
      where TCreateResult : class
      where TUpdateCommand : ICommand<TUpdateResult>
      where TUpdateResult : class
  ```

#### 3. Repositories
**Los repositorios ya tienen métodos CRUD disponibles:**
- Los repositorios heredan de `EfRepository<T>` que ya implementa:
  - `AddAsync()` - Para crear entidades
  - `UpdateAsync()` - Para actualizar entidades  
  - `GetByIdAsync()` - Para obtener por ID
  - `GetAllAsync()` - Para obtener todas las entidades
- **No se requieren modificaciones** en los repositorios existentes

### Frontend

#### 1. Servicios
**Crear servicios genéricos:**
- `src/frontend/src/app/shared/services/base-type.service.ts` - Servicio base genérico
- `src/frontend/src/app/shared/services/address-type.service.ts` - Servicio específico
- `src/frontend/src/app/shared/services/email-type.service.ts` - Servicio específico
- `src/frontend/src/app/shared/services/phone-type.service.ts` - Servicio específico
- `src/frontend/src/app/shared/services/social-media-type.service.ts` - Servicio específico

#### 2. Modelos
**Crear modelos:**
- `src/frontend/src/app/shared/models/base-type.models.ts` - Interfaces base
- `src/frontend/src/app/shared/models/address-type.models.ts` - Interfaces específicas
- `src/frontend/src/app/shared/models/email-type.models.ts` - Interfaces específicas
- `src/frontend/src/app/shared/models/phone-type.models.ts` - Interfaces específicas
- `src/frontend/src/app/shared/models/social-media-type.models.ts` - Interfaces específicas

#### 3. Componentes Genéricos
**Crear componentes reutilizables:**
- `src/frontend/src/app/shared/components/type-list/type-list.component.ts` - Componente genérico de lista
- `src/frontend/src/app/shared/components/type-list/type-list.component.html` - Template genérico
- `src/frontend/src/app/shared/components/type-modal/type-modal.component.ts` - Modal genérico para CRUD
- `src/frontend/src/app/shared/components/type-modal/type-modal.component.html` - Template del modal

#### 4. Componentes Específicos
**Reemplazar componentes existentes:**
- `src/frontend/src/app/address-type/address-type.component.ts` - Usar componente genérico
- `src/frontend/src/app/address-type/address-type.component.html` - Template simplificado
- `src/frontend/src/app/email-type/email-type.component.ts` - Usar componente genérico
- `src/frontend/src/app/email-type/email-type.component.html` - Template simplificado
- `src/frontend/src/app/phone-type/phone-type.component.ts` - Usar componente genérico
- `src/frontend/src/app/phone-type/phone-type.component.html` - Template simplificado
- `src/frontend/src/app/social-media/social-media.component.ts` - Usar componente genérico
- `src/frontend/src/app/social-media/social-media.component.html` - Template simplificado

#### 5. Routing
**Actualizar rutas:**
- `src/frontend/src/app/app.routes.ts` - Verificar rutas existentes

## Algoritmos y Lógica de Negocio

### 1. Validaciones
- **Nombre único**: Validar unicidad en base de datos antes de crear/actualizar
- **Límites de caracteres**: Name (50), Description (200) según script de BD
- **Campos obligatorios**: Name es requerido, Description es opcional
- **Estado**: IsActive por defecto true, se puede desactivar pero no eliminar

### 2. Paginación
- **Backend**: Implementar paginación en queries existentes siguiendo patrón de Company
- **Frontend**: Usar `DataTableComponent` con configuración de paginación
- **Tamaño de página**: 10 elementos por defecto, opciones [5, 10, 25, 50]

### 3. Operaciones CRUD
- **Create**: Modal con formulario simple (Name, Description)
- **Read**: Lista paginada con búsqueda por nombre
- **Update**: Modal pre-poblado con datos existentes
- **Delete**: Desactivar (IsActive = false) en lugar de eliminar

### 4. Refactorización y Herencia
- **BaseTypeCommand**: Comando base genérico con validaciones comunes
- **BaseTypeCommandHandler**: Handler base genérico con lógica CRUD común
- **BaseTypeResult**: Resultado base genérico con estructura consistente
- **BaseTypeService**: Servicio genérico en frontend para operaciones HTTP
- **TypeModalComponent**: Modal genérico reutilizable para todas las entidades

### 5. Beneficios de la Arquitectura Genérica
- **Máxima Reutilización**: Lógica común centralizada en abstracciones base
- **Consistencia**: Todos los tipos siguen el mismo patrón de implementación
- **Mantenibilidad**: Cambios en abstracciones base se aplican a todas las entidades
- **Extensibilidad**: Fácil agregar nuevos tipos siguiendo el mismo patrón
- **Menos Código**: Implementaciones específicas solo contienen lógica única

## Fases de Implementación por Entidad

**Estrategia de Desarrollo:**
- Implementar una entidad completa por vez (backend + frontend)
- AddressType como entidad piloto para establecer patrones
- Reutilizar componentes genéricos creados en AddressType para las demás entidades
- Validar funcionalidad completa antes de pasar a la siguiente entidad
- Refactorizar al final si se detecta código duplicado

### Fase 1: AddressType - Implementación Completa
**Backend:**
1. Crear abstracciones genéricas para comandos de tipos (`BaseTypeCommand`, `BaseTypeCommandHandler`, `BaseTypeResult`)
2. Extender `BaseTypesController` con métodos genéricos Create y Update
3. Implementar `CreateAddressType` (Command, Handler, Result) - Hereda de abstracciones genéricas
4. Implementar `UpdateAddressType` (Command, Handler, Result) - Hereda de abstracciones genéricas
5. Configurar inyección de dependencias

**Frontend:**
1. Crear servicio base genérico para tipos
2. Implementar `AddressTypeService` específico
3. Definir interfaces y modelos para AddressType
4. Crear componente de lista genérico reutilizable
5. Implementar modal genérico para CRUD
6. Reemplazar `address-type.component` con implementación genérica
7. Probar funcionalidad completa de AddressType

### Fase 2: EmailType - Implementación Completa
**Backend:**
1. Implementar `CreateEmailType` (Command, Handler, Result) - Hereda de abstracciones genéricas
2. Implementar `UpdateEmailType` (Command, Handler, Result) - Hereda de abstracciones genéricas
3. Configurar inyección de dependencias - Los endpoints ya están disponibles por herencia de BaseTypesController

**Frontend:**
1. Implementar `EmailTypeService` específico - Reutilizar `BaseTypeService`
2. Definir interfaces y modelos para EmailType - Reutilizar patrones de AddressType
3. Reemplazar `email-type.component` con implementación genérica - Reutilizar `TypeListComponent`
4. Probar funcionalidad completa de EmailType

### Fase 3: PhoneType - Implementación Completa
**Backend:**
1. Implementar `CreatePhoneType` (Command, Handler, Result) - Hereda de abstracciones genéricas
2. Implementar `UpdatePhoneType` (Command, Handler, Result) - Hereda de abstracciones genéricas
3. Configurar inyección de dependencias - Los endpoints ya están disponibles por herencia de BaseTypesController

**Frontend:**
1. Implementar `PhoneTypeService` específico - Reutilizar `BaseTypeService`
2. Definir interfaces y modelos para PhoneType - Reutilizar patrones establecidos
3. Reemplazar `phone-type.component` con implementación genérica - Reutilizar `TypeListComponent`
4. Probar funcionalidad completa de PhoneType

### Fase 4: SocialMediaType - Implementación Completa
**Backend:**
1. Implementar `CreateSocialMediaType` (Command, Handler, Result) - Hereda de abstracciones genéricas
2. Implementar `UpdateSocialMediaType` (Command, Handler, Result) - Hereda de abstracciones genéricas
3. Configurar inyección de dependencias - Los endpoints ya están disponibles por herencia de BaseTypesController

**Frontend:**
1. Implementar `SocialMediaTypeService` específico - Reutilizar `BaseTypeService`
2. Definir interfaces y modelos para SocialMediaType - Reutilizar patrones establecidos
3. Reemplazar `social-media.component` con implementación genérica - Reutilizar `TypeListComponent`
4. Probar funcionalidad completa de SocialMediaType

### Fase 5: Refactorización y Optimización
1. Refactorizar handlers genéricos si se detecta código duplicado
2. Optimizar componentes genéricos basado en uso real
3. Validar consistencia entre todas las entidades
4. Comprobar rendimiento y usabilidad
5. Documentar patrones establecidos para futuras entidades similares

## Consideraciones Técnicas

### Reutilización de Componentes
- **DataTableComponent**: Reutilizar para listas paginadas
- **ContentHeaderComponent**: Usar para headers consistentes
- **ModalComponent**: Crear modal genérico para formularios
- **FormValidation**: Implementar validaciones consistentes

### Patrones de Diseño
- **Generic Repository**: Para operaciones CRUD comunes
- **Command Pattern**: Para operaciones de negocio
- **Factory Pattern**: Para creación de componentes genéricos
- **Strategy Pattern**: Para validaciones específicas por tipo

### Consistencia con Company
- **Estructura de carpetas**: Seguir mismo patrón organizacional
- **Naming conventions**: Mantener consistencia en nombres
- **Error handling**: Usar mismo patrón de manejo de errores
- **Loading states**: Implementar estados de carga consistentes

## Validaciones de Negocio

### Backend
- Nombre único por tipo de entidad
- Límites de caracteres según esquema de BD
- Validación de existencia antes de actualizar
- Manejo de errores de constraint de BD

### Frontend
- Validación de formularios en tiempo real
- Mensajes de error consistentes
- Confirmación antes de desactivar elementos
- Feedback visual para operaciones asíncronas

## Criterios de Éxito
- Todas las entidades de tipo tienen funcionalidad CRUD completa
- Interfaz consistente y reutilizable
- Paginación funcionando correctamente
- Validaciones de negocio implementadas
- Código genérico reutilizable para futuras entidades similares
- Integración perfecta con sistema existente de Company
